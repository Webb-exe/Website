---
// LoadingAnimation.astro - GSAP SVG draw animation
---

<div id="loading-animation" class="fixed inset-0 z-100 flex items-center justify-center bg-dark pointer-events-auto" style="opacity: 1;">
  <div class="w-32 h-32 sm:w-40 sm:h-40 md:w-48 md:h-48">
    <svg
      id="loading-logo"
      data-name="Layer 1"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 159.59 76.99"
      class="w-full h-full"
    >
      <defs>
        <style>
          .cls-1 {
            fill: #a6a6a6;
            stroke: #a6a6a6;
            stroke-width: 1;
          }

          .cls-1, .cls-2, .cls-3 {
            stroke-miterlimit: 10;
          }

          .cls-2 {
            fill: #ffd5e0;
            stroke: #ffd5e0;
            stroke-width: 1;
          }

          .cls-3 {
            fill: #fdb4b9;
            stroke: #fdb4b9;
            stroke-width: 1;
          }
        </style>
      </defs>
      <path
        class="cls-1"
        d="M69.97,38.51C60.87,25.84,51.78,13.17,42.69.5H.67v12.94h46.78s.02,17.03.02,17.03h-24.21s0,12.92,0,12.92h23.82v18.86s-46.58,0-46.58,0l.08,14.25h42.1l27.28-37.98Z"
      />
      <path
        class="cls-3"
        d="M89.62,38.51c9.09-12.67,18.19-25.34,27.28-38.01h42.01v12.94h-46.78s-.02,17.03-.02,17.03h24.21s0,12.92,0,12.92h-23.82v18.86s46.58,0,46.58,0l-.08,14.25h-42.1l-27.28-37.98Z"
      />
      <polygon
        class="cls-2"
        points="61.75 .5 79.42 25.09 96.78 .5 61.75 .5"
      />
      <polygon
        class="cls-2"
        points="62.58 76.49 80.25 51.9 97.61 76.49 62.58 76.49"
      />
    </svg>
  </div>
</div>

<script>
  import gsap from 'gsap';

  let currentTimeline: gsap.core.Timeline | null = null;
  let isInitializing = false;

  // Reset SVG elements to initial state
  function resetSVGElements(svg: SVGElement) {
    const pathElements = svg.querySelectorAll('path');
    const polygonElements = svg.querySelectorAll('polygon');
    const allElements = [...Array.from(pathElements), ...Array.from(polygonElements)];

    allElements.forEach((element) => {
      // Kill any existing tweens
      gsap.killTweensOf(element);
      
      // Clear all GSAP properties
      gsap.set(element, { clearProps: 'all' });
      
      // Get length (force recalculation)
      const length = element.getTotalLength();
      
      // Directly set DOM properties to ensure reset
      const svgElement = element as any;
      if (svgElement.style) {
        svgElement.style.strokeDasharray = `${length}`;
        svgElement.style.strokeDashoffset = `${length}`;
        svgElement.style.fillOpacity = '0';
      }
      
      // Also set via GSAP for animation
      gsap.set(element, {
        strokeDasharray: length,
        strokeDashoffset: length,
        fillOpacity: 0,
        immediateRender: true,
        overwrite: true,
      });
    });
  }

  // Wait for DOM to be ready
  function initLoadingAnimation(retryCount = 0) {
    // Prevent infinite retries
    if (retryCount > 10) {
      console.warn('LoadingAnimation: Failed to initialize after multiple retries');
      isInitializing = false;
      return;
    }
    
    const container = document.getElementById('loading-animation');
    const svgElement = document.getElementById('loading-logo');
    const svg = svgElement instanceof SVGElement ? svgElement : null;
    
    if (!svg || !container) {
      requestAnimationFrame(() => initLoadingAnimation(retryCount + 1));
      return;
    }

    // Kill any existing animations first
    if (currentTimeline) {
      currentTimeline.kill();
      currentTimeline = null;
    }

    // Reset initialization flag if we're retrying
    if (isInitializing && retryCount > 0) {
      isInitializing = false;
    }
    
    // Prevent multiple simultaneous initializations (but allow retries)
    if (isInitializing && retryCount === 0) {
      return;
    }

    isInitializing = true;

    // Reset container state for new animation (keep flex for centering)
    container.style.display = 'flex';
    container.style.opacity = '1';
    container.style.pointerEvents = 'auto';

    // Kill any existing tweens on container
    gsap.killTweensOf(container);
    gsap.set(container, { clearProps: 'opacity', overwrite: true });

    // Force a reflow to ensure the container is visible before animating
    void container.offsetHeight;

    // Reset SVG elements immediately
    resetSVGElements(svg);

    // Small delay to ensure everything is rendered
    setTimeout(() => {
      // Double-check elements still exist
      const containerCheck = document.getElementById('loading-animation');
      const svgCheck = document.getElementById('loading-logo');
      if (!containerCheck || !svgCheck) {
        isInitializing = false;
        initLoadingAnimation(retryCount + 1);
        return;
      }

      // Get all paths and polygons from the SVG
      const pathElements = svg.querySelectorAll('path');
      const polygonElements = svg.querySelectorAll('polygon');
      
      const paths = Array.from(pathElements);
      const polygons = Array.from(polygonElements);

      if (paths.length === 0 && polygons.length === 0) {
        isInitializing = false;
        initLoadingAnimation(retryCount + 1);
        return;
      }

      // Ensure elements are still reset (in case DOM changed)
      resetSVGElements(svg);

      // Create animation timeline
      currentTimeline = gsap.timeline({
        onComplete: () => {
          isInitializing = false;
          // Fade out the loading screen
          gsap.to(container, {
            opacity: 0,
            duration: 0.5,
            ease: 'power2.in',
            onComplete: () => {
              // Disable pointer events after fade out
              if (container) {
                container.style.pointerEvents = 'none';
                // Hide after animation
                container.style.display = 'none';
              }
              currentTimeline = null;
              
              // Dispatch custom event to signal animation completion
              window.dispatchEvent(new CustomEvent('loading-animation-complete'));
            },
          });
        },
      });

      // Draw paths sequentially
      paths.forEach((path, index) => {
        const length = path.getTotalLength();
        currentTimeline!.to(
          path,
          {
            strokeDashoffset: 0,
            duration: 0.8,
            ease: 'power2.out',
          },
          index * 0.15
        );
        // Fill in after stroke completes
        currentTimeline!.to(
          path,
          {
            fillOpacity: 1,
            duration: 0.3,
            ease: 'power1.in',
          },
          `-=${0.2}`
        );
      });

      // Draw polygons (they appear last)
      polygons.forEach((polygon, index) => {
        const length = polygon.getTotalLength();
        currentTimeline!.to(
          polygon,
          {
            strokeDashoffset: 0,
            duration: 0.6,
            ease: 'power2.out',
          },
          paths.length * 0.15 + index * 0.1
        );
        currentTimeline!.to(
          polygon,
          {
            fillOpacity: 1,
            duration: 0.3,
            ease: 'power1.in',
          },
          `-=${0.2}`
        );
      });

      // Hold for a moment before fading out
      currentTimeline!.to({}, { duration: 0.5 });
    }, 50);
  }

  // Initialize on page load
  function startAnimation() {
    initLoadingAnimation();
  }

  // Start animation when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startAnimation);
  } else {
    startAnimation();
  }

  // Handle page transitions - reset and restart animation
  function handlePageTransition() {
    // Kill any running animation immediately
    if (currentTimeline) {
      currentTimeline.kill();
      currentTimeline = null;
    }
    // Reset flag to allow new initialization
    isInitializing = false;

    // Use requestAnimationFrame to ensure DOM is ready
    requestAnimationFrame(() => {
      // Reset the container immediately to ensure it's visible
      const container = document.getElementById('loading-animation');
      const svgElement = document.getElementById('loading-logo');
      const svg = svgElement instanceof SVGElement ? svgElement : null;
      
      if (container) {
        container.style.display = 'flex';
        container.style.opacity = '1';
        container.style.pointerEvents = 'auto';
        
        // Kill any tweens on container
        gsap.killTweensOf(container);
        gsap.set(container, { clearProps: 'opacity', overwrite: true });
      }

      // Reset SVG elements immediately if they exist
      if (svg) {
        resetSVGElements(svg);
      }
      
      // Wait a bit for the new page to be ready, then start animation
      // Use a slightly longer delay to ensure DOM is fully ready
      setTimeout(() => {
        // Reset flag again before starting (in case something set it)
        isInitializing = false;
        initLoadingAnimation(0);
      }, 200);
    });
  }

  // Handle before-preparation to catch transitions early
  function handleBeforePreparation() {
    // Kill current animation immediately when transition starts
    if (currentTimeline) {
      currentTimeline.kill();
      currentTimeline = null;
    }
    isInitializing = false;
  }

  // Handle before-swap to reset state
  function handleBeforeSwap() {
    // Kill current animation immediately
    if (currentTimeline) {
      currentTimeline.kill();
      currentTimeline = null;
    }
    isInitializing = false;
    
    // Reset container state immediately
    const container = document.getElementById('loading-animation');
    const svgElement = document.getElementById('loading-logo');
    const svg = svgElement instanceof SVGElement ? svgElement : null;
    
    if (container) {
      container.style.display = 'flex';
      container.style.opacity = '1';
      container.style.pointerEvents = 'auto';
      gsap.killTweensOf(container);
      gsap.set(container, { clearProps: 'opacity', overwrite: true });
    }
    
    // Reset SVG elements if they exist
    if (svg) {
      resetSVGElements(svg);
    }
  }

  // Re-run animation on each page transition
  document.addEventListener('astro:page-load', handlePageTransition);
  
  // Catch transitions that happen during animation
  document.addEventListener('astro:before-preparation', handleBeforePreparation);
  document.addEventListener('astro:before-swap', handleBeforeSwap);
  
  // Also handle after-swap as a fallback
  document.addEventListener('astro:after-swap', () => {
    // Small delay to ensure DOM is fully ready
    setTimeout(() => {
      const container = document.getElementById('loading-animation');
      if (container && container.style.display === 'none') {
        // If container is hidden, restart animation
        handlePageTransition();
      }
    }, 50);
  });
</script>

